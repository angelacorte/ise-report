\section{Dettagli Implementativi}

\subsection{Tecnologie Utilizzate}

\subsubsection{Kotlin}

Per lo sviluppo del progetto è stato scelto di utilizzare Kotlin\cite{kotlin} come linguaggio di programmazione, questo perché la base di codice presente in JaKtA è anch'essa scritta in tale linguaggio.

Kotlin è un linguaggio di programmazione moderno, conciso e altamente espressivo, progettato per interoperare completamente con Java\cite{java}.
Con una sintassi chiara e concisa, gestione avanzata delle nullità, estensioni delle funzioni e il supporto nativo per la programmazione orientata agli oggetti, Kotlin offre un ambiente di sviluppo robusto e flessibile.

\subsubsection{Gradle}

Come \textit{build system} è stato scelto di utilizzare quello già presente in JaKtA, ovvero Gradle\cite{gradle}.

Gradle è un sistema di automazione della compilazione e gestione delle dipendenze. Basato su un modello di configurazione dichiarativa, Gradle semplifica il processo di costruzione e gestione dei progetti, fornendo una sintassi chiara e potente basata su Groovy\cite{groovy} o Kotlin.

\subsubsection{Ktor}

Per la gestione delle comunicazioni di rete tra \textit{Client} e \textit{Broker} è stato scelto di utilizzare la libreria Ktor\cite{ktor}.

Ktor è un \textit{framework} di sviluppo web moderno e leggero scritto in Kotlin, progettato per semplificare la creazione di applicazioni web robuste e performanti. Offre un approccio dichiarativo e conciso per gestire le richieste \textit{HTTP} e costruire servizi web. Il \textit{framework} permette la programmazione asincrona e non bloccante, inoltre ha la capacità di integrarsi senza sforzo con altre tecnologie Kotlin, come le \textit{coroutine}

\subsubsection{JUnit}

Per testare il funzionamento dei moduli sviluppati è stato utilizzato il \textit{framework} JUnit\cite{junit}.

Creato per semplificare e migliorare il processo di \textit{testing}, JUnit fornisce un set di \textit{annotation} e \textit{assert} che consentono agli sviluppatori di definire e eseguire facilmente gli \textit{unit test}.

\subsection{Broker}
Il \textit{broker} implementato in Kotlin utilizza il \textit{framework} Ktor per gestire la comunicazione asincrona attraverso \textit{WebSocket} e le richieste \textit{HTTP}. Questo \textit{broker} distribuito si basa su due principali componenti: \texttt{Cache} e \texttt{SubscriptionManager}.

Interfaccia \texttt{Cache<T>}:

\begin{itemize}
    \item È Responsabile della memorizzazione temporanea di dati associati a specifici \textit{topic}.
    \item Fornisce operazioni come la registrazione di dati, la liberazione di risorse e la lettura di dati associati a un \textit{topic} specifico.
\end{itemize}

\texttt{SubscriptionManager<T>}:

\begin{itemize}
    \item Offre operazioni per aggiungere e rimuovere \textit{publisher} e \textit{subscriber} associati a specifici \textit{topic}.
    \item Fornisce informazioni sui \textit{topic} disponibili e sulle sezioni associate a un determinato \textit{topic}.
\end{itemize}

Endpoint e Routing:

\begin{itemize}
    \item Il modulo \texttt{configureWebSockets} definisce i \textit{WebSocket endpoint} per la pubblicazione e la sottoscrizione di dati relativi a specifici \textit{topic}.
    \item Il modulo \textit{configureRouting} configura le \textit{route HTTP} per ottenere informazioni sui \textit{topic} disponibili.
\end{itemize}

\subsection{Adapter}
Per realizzare una versione di sistema multi agente in grado di comunicare con l'esterno, è stata estesa l'interfaccia Mas con l'interfaccia Dmas:

\begin{lstlisting}[language=Kotlin]
interface Dmas : Mas {
    val network: Network
    val remoteServices: List<RemoteService>
}
\end{lstlisting}

Un'implementazione del Dmas può dunque essere usata in vece del Mas dalla logica applicativa principale del framework, ma in aggiunta può servirsi di Network e RemoteService per
implementare la logica di comunicazione con l'esterno.\\

Per quanto riguarda l'implementazione dell'interfaccia Network, che incapsula la logica di comunicazione tra Dmas attraverso la rete, è stata scelta una soluzione basata sull'uso
di un client WebSocket, che verrà trattato nel dettaglio nel paragrafo successivo.\\

\subsection{Client}
L'applicativo del client è progettato per gestire la comunicazione attraverso WebSocket,
facendo uso del framework Ktor in Kotlin. Per affrontare la natura distribuita del progetto,
sono state definite entità chiave, tra cui \textit{Client}, \textit{WebSocketSession}, e i modelli di dati
\textit{SerializableSendMessage} e \textit{SerializableBroadcastMessage}. \\

L'interfaccia Client svolge il ruolo di punto principale di accesso, incapsulando le funzionalità fondamentali per la
comunicazione. La sua implementazione chiave è rappresentata dalla classe \textit{WebSocketsClient}.\\

La classe WebSocketsClient è una componente centrale per gestire le connessioni WebSocket.
È responsabile della creazione e gestione di sessioni WebSocket per la pubblicazione,
la sottoscrizione e la trasmissione di messaggi. Inoltre, tiene traccia delle connessioni attive, delle disconnessioni e dei messaggi in arrivo.\\

I modelli \textit{SerializableSendMessage} e \textit{SerializableBroadcastMessage} sono essenziali per rappresentare i messaggi scambiati tra il client e
il server. La loro struttura è progettata per garantire una corretta serializzazione e deserializzazione dei dati. \\

Vengono implementate tre funzionalità principali:
\begin{itemize}
    \item \texttt{publish}: si occcupa di inviare un messaggio ad un determinato 'topic' attraverso una connessione WebSocket;
    \item \texttt{broadcast}: simile alla funzione sopra citata ma è destinata ad unviare un messaggio a tutti i client connessi;
    \item \texttt{subscribe}: gestisce l'iscrizione del client ad un particolare 'topic' attraverso una connessione WebSocket.
\end{itemize}

Per quanto riguarda la gestione dei messaggi in arrivo, la funzione \texttt{subscribe}.
Questa funzione rimane in ascolto dei messaggi inviati al 'topic' specificato, deserializza i messaggi ricevuti e li memorizza per un successivo utilizzo.
Questo meccanismo è fondamentale per garantire una comunicazione bidirezionale efficace tra il client e il server.

\subsection{Note Implementative}
In questa sezione si vuole fare chiarezza su alcune scelte implementative che possono ritenersi sub ottimali, che sono state fatte per motivi di tempo e/o di complessità.

\subsubsection{RemoteService}
Il RemoteService funge da rappresentazione di un agente remoto, cioè un agente che appartiene ad un Dmas diverso da quello corrente, ma contattabile attraverso la rete.
Esso è identificato dal suo nome e viene specificato in fase di creazione del Dmas. È importante notare che, al momento, non è stato implementato un meccanismo che renda
univoci i nomi dei RemoteService per tutti i Dmas, quindi è possibile che due Dmas diversi abbiano un RemoteService con lo stesso nome, causando possibili duplicazioni dei
messaggi intesi invece per un singolo destinatario.\\

È stata valutata l'opzione di prefiggere al nome del RemoteService un codice univoco, tuttavia, siccome nel corrente design il RemoteService viene specificato in fase di creazione
del Dmas, non è possibile conoscere a priori il codice univoco da utilizzare. C'è inoltre il riscio che due Dmas diversi, essendo in processi separati, generino lo stesso codice
prefisso.\\

\subsubsection{Nomi riservati}
Esistono due nomi di RemoteService da ritenersi riservati: \texttt{broker} e \texttt{broadcast}. Il primo è il nome del RemoteService del Broker, mentre il secondo è utilizzato 
per effettuare broadcasting dei messaggi.\\

Attualmente non è in funzione alcun meccanismo che impedisca un programmatore di chiamare un agente del proprio Dmas con i nomi sopra citati, tuttavia, farlo potrebbe causare comportamenti
inaspettati del sistema.\\