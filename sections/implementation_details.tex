\section{Dettagli Implementativi}

\subsection{Tecnologie Utilizzate}

\subsubsection{Kotlin}

Per lo sviluppo del progetto è stato scelto di utilizzare Kotlin\cite{kotlin} come linguaggio di programmazione, questo perché la base di codice presente in JaKtA è anch'essa scritta in tale linguaggio.

Kotlin è un linguaggio di programmazione moderno, conciso e altamente espressivo, progettato per interoperare completamente con Java\cite{java}.
Con una sintassi chiara e concisa, gestione avanzata delle nullità, estensioni delle funzioni e il supporto nativo per la programmazione orientata agli oggetti, Kotlin offre un ambiente di sviluppo robusto e flessibile.

\subsubsection{Gradle}

Come \textit{build system} è stato scelto di utilizzare quello già presente in JaKtA, ovvero Gradle\cite{gradle}.

Gradle è un sistema di automazione della compilazione e gestione delle dipendenze. Basato su un modello di configurazione dichiarativa, Gradle semplifica il processo di costruzione e gestione dei progetti, fornendo una sintassi chiara e potente basata su Groovy\cite{groovy} o Kotlin.

\subsubsection{Ktor}

Per la gestione delle comunicazioni di rete tra \textit{Client} e \textit{Broker} è stato scelto di utilizzare la libreria Ktor\cite{ktor}.

Ktor è un \textit{framework} di sviluppo web moderno e leggero scritto in Kotlin, progettato per semplificare la creazione di applicazioni web robuste e performanti. Offre un approccio dichiarativo e conciso per gestire le richieste \textit{HTTP} e costruire servizi web. Il \textit{framework} permette la programmazione asincrona e non bloccante, inoltre ha la capacità di integrarsi senza sforzo con altre tecnologie Kotlin, come le \textit{coroutine}

\subsubsection{JUnit}

Per testare il funzionamento dei moduli sviluppati è stato utilizzato il \textit{framework} JUnit\cite{junit}.

Creato per semplificare e migliorare il processo di \textit{testing}, JUnit fornisce un set di \textit{annotation} e \textit{assert} che consentono agli sviluppatori di definire e eseguire facilmente gli \textit{unit test}.

\subsection{Broker}
La base dell'applicazione è costituita dal \texttt{SubscriptionManager}, che gestisce la registrazione e la rimozione di \textit{publisher} e \textit{subscriber} attraverso connessioni \textit{WebSocket}. È inoltre presente un modulo che definisce le configurazioni per le \textit{route HTTP} che forniscono informazioni sui \textit{topic} disponibili.

\subsection{Client}
L'applicativo del client è progettato per gestire la comunicazione attraverso WebSocket,
facendo uso del framework Ktor in Kotlin. Per affrontare la natura distribuita del progetto,
sono state definite entità chiave, tra cui \textit{Client}, \textit{WebSocketSession}, e i modelli di dati
\textit{SerializableSendMessage} e \textit{SerializableBroadcastMessage}. \\

L'interfaccia Client svolge il ruolo di punto principale di accesso, incapsulando le funzionalità fondamentali per la
comunicazione. La sua implementazione chiave è rappresentata dalla classe \textit{WebSocketsClient}.\\

La classe WebSocketsClient è una componente centrale per gestire le connessioni WebSocket.
È responsabile della creazione e gestione di sessioni WebSocket per la pubblicazione,
la sottoscrizione e la trasmissione di messaggi. Inoltre, tiene traccia delle connessioni attive, delle disconnessioni e dei messaggi in arrivo.\\

I modelli \textit{SerializableSendMessage} e \textit{SerializableBroadcastMessage} sono essenziali per rappresentare i messaggi scambiati tra il client e
il server. La loro struttura è progettata per garantire una corretta serializzazione e deserializzazione dei dati. \\

Vengono implementate tre funzionalità principali:
\begin{itemize}
    \item \texttt{publish}: si occcupa di inviare un messaggio ad un determinato 'topic' attraverso una connessione WebSocket;
    \item \texttt{broadcast}: simile alla funzione sopra citata ma è destinata ad unviare un messaggio a tutti i client connessi;
    \item \texttt{subscribe}: gestisce l'iscrizione del client ad un particolare 'topic' attraverso una connessione WebSocket.
\end{itemize}

Per quanto riguarda la gestione dei messaggi in arrivo, la funzione \texttt{subscribe}.
Questa funzione rimane in ascolto dei messaggi inviati al 'topic' specificato, deserializza i messaggi ricevuti e li memorizza per un successivo utilizzo.
Questo meccanismo è fondamentale per garantire una comunicazione bidirezionale efficace tra il client e il server.

